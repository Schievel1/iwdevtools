#!/usr/bin/env bash
. "${0%/*}"/../lib/common.bashlib || exit 1 #C#
init
depend find q sort xmllint
include atomf shellparse
usage <<-EOU
	Usage: ${0##*/} [options] [atom]

	Print directory location (or change directory with *Shell Integration*
	below) plus some information corresponding to an atom either using
	/etc/portage/repos.conf or a repo list given using the -P/--path option.

	atom can be partial or missing, e.g. from dev-category/example::repo
	  - dev-category : print category directory
	  - example      : lookup matches in all categories
	  - example::repo: limit to repo by ::name
      - (nothing)    : print the repository's top level directory
	  - .            : show information again for current directory
	In all cases, will ask if multiple results unless -1/--first is specified.

	Options:
	  -P, --path=PATH:... Specify list of repos to search ordered by priority,
	                      special keyword "default" adds all from repos.conf
	                      (e.g. --path="~/gentoo:/tmp/overlay:default")
	  -D, --duplicates    Allow multiple repos with the same profiles/repo_name
	                      (e.g. keep /var/db/repos/gentoo even if have ~/gentoo)

	  -1, --first         Disable interactive prompts and always pick first choice

	      --bash=alias    Print integration code, see *Shell Integration* below

	  -c, --no-color      Disable use of colors

	      --confdir=PATH  Configuration dir to use instead of defaults
	                      (@confdir@ + ${XDG_CONFIG_HOME:-~/.config}/@package@)
	      --dumpconfig    Display config and exit (> ${0##*/}.conf)

	  -h, --help          Display usage information and exit
	      --version       Display version information and exit

	*Known Limitations*
	Some information may be missing if ebuilds rely on eclasses to set DESCRIPTION
	or HOMEPAGE without metadata/md5-cache. cpe-type remote-ids are unsupported.

	*Shell Integration*
	To be able to change the directory of an interactive shell, a higher level
	helper is required, i.e. if ${0##*/} prints a path, then cd to it.

	For bash, --bash[=alias] can be used to simplify, e.g. to be able to
	use \`rcd <atom>\`, can add to ~/.bashrc (and/or run in current shell):

	 > eval "\$(command ${0##*/} --bash=rcd --path=/custom/for/this/alias)"
EOU

setmsg 2 # stdout only used to show cd path or shell integration

optauto args "${@}" <<-EOO
	P|path=str:default
	D|duplicates=bool:false
	1|first=bool:false
	bash=str:
	c|!color=bool:true
EOO

# rcd-shell_integration <args>
#	Print shell integration code using <args> after stripping
#	integration options.
# TODO: more shells, possibly some degree of completion support
rcd-shell_integration() {
	local -a args=()
	while (( ${#} )); do
		case ${1} in
			--bash) shift 2; continue;;
			--bash=*) shift; continue;;
		esac
		args+=("${1}")
		shift
	done

	#!SC2016
	printf \
'%s() {
	local d
	d=$(command %q%s "${@}") &&
		[[ -n ${d} ]] && cd "${d}"
}\n' "${O[bash]}" "${0##*/}" "${args[0]+ }${args[*]@Q}"

}
if [[ ${O[bash]} ]]; then
	rcd-shell_integration "${@}"
	exit
fi

set -- "${args[@]}"; unset args
(( ${#} <= 1 )) || die "too many atoms given, see \`${0##*/} --help\`"

# rcd-ask <variable> <choice>...
#	Ask to pick from <choices> and store result in <variable>.
#	If only one choice, do nothing beside set <variable> to it.
#	If choice starts with ${HOME}, replaces with ~ only when displaying.
rcd-ask() {
	local -n outref=${1}
	shift

	if ${O[first]} || (( ${#} == 1 )); then
		outref=${1}
		return 0
	fi

	local default=" ${C[a]}(default)${C[n]}"
	local -i i
	for ((i=1; i<=${#}; i++)); do
		rcd-msg '?m' "${C[y]}${i}${C[a]}:${C[c]}${!i/#"${HOME}"/\~}${C[n]}${default}"
		default=
	done

	rcd-msg -n '?y' "Choice? "

	local REPLY
	read -ren ${##}
	printf -v i %u "${REPLY}" 2>/dev/null
	(( i <= 1 || i > ${#} )) && i=1 # default if non-integer / invalid reply

	outref=${!i} #!SC2034
}

# rcd-cd [atom]
#	Print directory for atom (or repo if missing) and change directory.
#	Exit with value 104 if failed to find a directory to use.
#	Return 1 if resulting directory is not a package directory.
rcd-cd() {
	local cd
	if (( ! ${#} )); then
		# if no atom, just cd to repo's top level
		rcd-ask cd "${REPOPATH[@]}"
	elif [[ ${1} == . ]]; then
		# repeat current to show information again if under a REPOPATH
		cd=
		for path in "${REPOPATH[@]}"; do
			if [[ ${PWD} =~ ^"${path}"(/.*)? ]]; then
				cd=${PWD}
				break
			fi
		done

		if [[ ! ${cd} ]]; then
			rcd-msg '!r' "requested current directory is not a known repo"
			exit 104
		fi
	else
		local search=${1%/} # trim / in case did tab-complete on a directory

		# most atom elements are unused, but atomsp can sanitize input
		local atom
		atomsp atom "${search}" && [[ ${atom[3]} ]] \
			|| die "invalid search '${search}'"

		# support portage-like ::repo_name if given
		local userepo=
		[[ ${search} =~ ::([A-Za-z0-9_-]+)$ ]] && userepo=${BASH_REMATCH[1]}

		local cat=${atom[2]:-}
		local name=${atom[3]} # can be a category-only search
		local depth=1
		local omit=( -name '.*' )

		# TODO: exclusion options, virtual/ by default, probably haskell too

		if [[ ! ${cat} ]]; then
			# no category, need to go deeper
			depth=2
			omit+=(
				# omit a few known non-category directories (ideally would
				# load category files, but REPOPATH lacks the full picture)
				-o -path '{}/metadata'
				-o -path '{}/licenses'
				-o -path '{}/scripts'
				-o -path '{}/eclass'
				-o -path '{}/profiles'
			)
		fi

		# want search to work on independent non-repos.conf, and not take too
		# long, so use raw find(1) and sort per repo to be predictable
		local path
		local -a choice=()
		for path in "${REPOPATH[@]}"; do
			[[ ! ${userepo} || ${REPONAME[${path}]} == "${userepo}" ]] || continue

			path+=${cat:+/}${cat}
			[[ -d ${path} ]] || continue

			find "${path}" -maxdepth "${depth}" \
				\( "${omit[@]/'{}'/${path}}" \) -prune \
				-o -type d -iname "${name}" -print0 | sort -z
		done | mapfile -d '' -t choice

		if (( ! ${#choice[@]} )); then
			rcd-msg '!r' "no match found for '${C[m]}${search}${C[n]}'${userepo:+ in ::${userepo}}"
			exit 104
		fi

		rcd-ask cd "${choice[@]}"
	fi

	rcd-msg '>gc' "${cd/#"${HOME}"/\~}"
	cd "${cd}" || die "failed to cd '${cd}'"
	echo "${cd}" # for the interactive shell to use

	# roughly figure out if find(1)+rcd-ask gave a package directory without
	# assuming from files, e.g. skel.ebuild is not from a package
	for path in "${REPOPATH[@]}"; do
		[[ ${path} == "${PWD%/*/*}" ]] && return 0
	done
	return 1
}

# rcd-get_metadata <array> <path[]> [attribute]...
#	Get metadata.xml (current dir) results using xml <path> then store in
#	<array>. If [attribute], will be set at start of array with a space,
#	[] indicates the single element to iterate and use [attribute] for.
#	e.g.
#	'upstream/remote-id[]' type -> "github repo/location"
#	'maintainer[]/email' type missing -> "person  larry@gentoo.org"
#	Return 1 on xmllint errors (malformed, or couldn't read metadata.xml)
rcd-get_metadata() {
	local -n outref=${1}
	local path=${2}
	shift 2

	local -i i max
	max=$(xmllint --nonet --xpath \
		"count(//pkgmetadata/${path%%'[]'*})" metadata.xml) || return 1

	local xpath=
	if (( ${#} )); then
		while (( ${#} )); do
			xpath+="//pkgmetadata/${path/'[]'*/[]/@${1}},' ',"
			shift
		done
		xpath="concat(${xpath}normalize-space(//pkgmetadata/${path}))"
	else
		xpath="normalize-space(//pkgmetadata/${path})"
	fi

	outref=()
	for ((i=1; i<=max; i++)); do
		outref+=("$(xmllint --nonet --xpath \
			"${xpath//'[]'/[${i}]}" metadata.xml)") || return 1
	done
}

# rcd-get_metadata_remote_urls <array>
#	Set <array> with remote urls defined by metadata.xml remote-ids.
#	Issues a warning if unknown remote-ids.
#	Return 1 if rcd-get_metadata failed
rcd-get_metadata_remote_urls() {
	local -n outref=${1} #!SC2178
	outref=()

	local -a remoteids
	rcd-get_metadata remoteids 'upstream/remote-id[]' type || return 1

	local entry remoteids
	outref=()
	for entry in "${remoteids[@]}"; do
		id=${entry#* }

		# based on https://gitweb.gentoo.org/sites/soko.git/tree/pkg/app/handler/packages/utils.go
		case ${entry%% *} in
			bitbucket) outref+=("https://bitbucket.org/${id}/");;
			cpan-module) outref+=("https://metacpan.org/pod/${id}");;
			cpan) outref+=("https://metacpan.org/dist/${id}");;
			cpe) continue;; # unhandled
			cran) outref+=("https://cran.r-project.org/web/packages/${id}/");;
			ctan) outref+=("https://ctan.org/pkg/${id}/");;
			gentoo) outref+=("https://gitweb.gentoo.org/${id}.git/");;
			github) outref+=("https://github.com/${id}/");;
			gitlab) outref+=("https://gitlab.com/${id}/");;
			gitorious) outref+=("https://gitorious.org/${id}/");;
			google-code) outref+=("https://code.google.com/archive/p/${id}/");;
			heptapod) outref+=("https://foss.heptapod.net/${id}/");;
			launchpad) outref+=("https://launchpad.net/${id}/");;
			osdn) outref+=("https://osdn.net/projects/${id}/");;
			pear) outref+=("https://pear.php.net/package/${id}/");;
			pecl) outref+=("https://pecl.php.net/package/${id}/");;
			pypi) outref+=("https://pypi.org/project/${id}/");;
			rubygems) outref+=("https://rubygems.org/gems/${id}/");;
			sourceforge) outref+=("https://sourceforge.net/projects/${id}/");;
			vim) outref+=("https://www.vim.org/scripts/script.php?script_id=${id}");;
			*)
				rcd-msg '!ra' "metadata.xml: unknown remote-id ${entry%% *}"
				continue
			;;
		esac
	done
}

# rcd-msg [-n] <char><prefix-color-id>[message-color-id] <message>...
#	Print message with <char> prefix, e.g. msg '!r' "prefixed by red !".
#	Multiple arguments will result in multiple lines with same prefix.
#	Skip trailing newline if -n.
#	More complex coloring can be used in the message itself.
# TODO: redo the whole color-id thing.. doesn't allow nn color codes
rcd-msg() {
	local trail=1
	if [[ ${1} == -n ]]; then
		trail=
		shift
	fi
	local mcolor=${1:2:1}
	printf " ${C[${1:1:1}]}${1::1} ${C[${mcolor:-n}]}%s${C[n]}${trail:+\n}" "${@:2}" >&2
}

# rcd-print_package_data
#	Print basic info package in ${PWD}, and aggregates HOMEPAGEs and
#	remote-ids to print all while trying to avoid duplicates.
rcd-print_package_data() {
	local -a homesort=() maintainers=()
	local -A homeindex
	local cache description= data note ebuild pvr

	local -i i
	for ((i=0; i<${#ATOM[@]}; i++)); do
		local -n atom=${ATOM[i]}
		local -n si=${SI[i]}
		pvr=${atom[4]}${atom[5]:+-r${atom[5]}}

		# check md5-cache to see eclass-set values (inherit is unhandled),
		# and then ebuild to be up to date or fallback if cache is missing
		cache=../../metadata/md5-cache/${atom[2]}/${atom[3]}-${pvr}
		if [[ -d ../../metadata/md5-cache && -f ${cache} ]]; then
			note="${pvr}, cached"
			while IFS= read -r data; do
				case ${data} in
					DESCRIPTION=*)
						description="${C[ly]}${data#DESCRIPTION=} ${C[a]}(${note})${C[n]}"
					;;
					HOMEPAGE=*)
						for data in ${data#HOMEPAGE=}; do
							_rcd_print_package_data_add_homepage
						done
					;;
				esac
			done < "${cache}" || die "failed to read '${cache}'"
		fi

		note=${pvr}

		[[ ${si[DESCRIPTION]:-} ]] &&
			description="${C[ly]}${si[DESCRIPTION]} ${C[a]}(${note})${C[n]}"

		for data in ${si[HOMEPAGE]:-}; do
			_rcd_print_package_data_add_homepage
		done
	done

	if [[ -f metadata.xml ]]; then
		local -a metabugs metachangelog metadocs metamaints metaurls
		# stop if any reported errors as will likely all fail and be noisy
		if rcd-get_metadata metabugs 'upstream/bugs-to[]' &&
			rcd-get_metadata metachangelog 'upstream/changelog[]' &&
			rcd-get_metadata metadocs 'upstream/doc[]' &&
			rcd-get_metadata_remote_urls metaurls &&
			rcd-get_metadata metamaints 'maintainer[]/email' type proxied
		then
			note=
			for data in "${metaurls[@]}"; do
				_rcd_print_package_data_add_homepage
			done

			note=doc
			for data in "${metadocs[@]}"; do
				_rcd_print_package_data_add_homepage
			done

			note=bugs-to
			for data in "${metabugs[@]}"; do
				_rcd_print_package_data_add_homepage
			done

			note=changelog
			for data in "${metachangelog[@]}"; do
				_rcd_print_package_data_add_homepage
			done

			for data in "${metamaints[@]}"; do
				if [[ ${data} =~ ([^ ]*)\ ([^ ]*)\ (.+) ]]; then
					if [[ ${BASH_REMATCH[2]} == proxy ]]; then
						data=${C[a]}
					elif [[ ${BASH_REMATCH[2]} == yes ]]; then
						data=${C[m]}
					elif  [[ ${BASH_REMATCH[1]} == project ]]; then
						data=${C[g]}
					else
						data=${C[lm]}
					fi
					maintainers+=("${data}${BASH_REMATCH[3]}${C[n]}")
				fi
			done
		else
			rcd-msg '!ra' "metadata.xml: issues reading, info may be missing"
		fi
	fi
	(( ${#maintainers[@]} )) || maintainers=("${C[a]}maintainer-needed${C[n]}")

	# display contents
	[[ ${description} ]] && rcd-msg Dgy "${description}"

	for data in "${homesort[@]}"; do
		rcd-msg Hg "${homeindex[${data}]}"
	done

	rcd-msg Mg "${maintainers[*]}"
}
_rcd_print_package_data_add_homepage() {
	# build simplified HOMEPAGE index (no http:, trailing /, nor index.*) to
	# detect most duplicates, latest name will be used unless it's a remote-id

	local trim=${data#*://}
	trim=${trim%index.*}
	trim=${trim%/}

	# remember sort order given bash doesn't with hashes
	[[ -v homeindex['${trim}'] ]] || homesort+=("${trim}")

	homeindex[${trim}]="${C[lb]}${data}${note:+ ${C[a]}(${note})}${C[n]}"
}

# rcd-set_atom_and_si
#	Fill ATOM and SI arrays for all valid ebuilds in current directory
#	(if any). Each element has a atomsp() and shellimport() reference.
declare -a ATOM=() SI=()
rcd-set_atom_and_si() {
	local cat ebuild
	local -i i=0

	cat=${PWD%/*}
	cat=${cat##*/}

	set +f
	local -a ebuilds=( *.ebuild )
	set -f

	# true PMS-sorting is not essential but still at least sort -V so
	# e.g. HOMEPAGE outputs have right order
	# TODO?: atomf.bashlib could have basic compare/sort, see eapi7-ver.eclass
	printarray ebuilds | sort -V | map ebuilds || die

	for ebuild in "${ebuilds[@]}"; do
		local -n atom=RCD_ATOM_${i}
		local -n si=RCD_SI_${i}
		if atomsp "${!atom}" "=${cat}/${ebuild}" &&
			[[ ${atom[2]:-} && ${atom[3]:-} && ${atom[4]:-} ]]; then
			if shellimport "${!si}" "${ebuild}"; then
				ATOM+=("${!atom}")
				SI+=("${!si}")
				i+=1
			else
				rcd-msg '!ra' "=${cat}/${ebuild%.ebuild}: ignored (shellimport failed)"
			fi
		else
			rcd-msg '!ra' "=${cat}/${ebuild%.ebuild}: ignored (invalid atom)"
		fi
	done
}

# rcd-set_repopath
#	Set REPOPATH array based on O[path] string.
#	Also sets REPONANE[${path}] for name lookup.
#	Skip repos with the same name in metadata/layout.conf so that e.g.
#	path=~/gentoo:default doesn't asks to pick every time.
#	Skip and warn for invalid paths, dies if none left.
declare -A REPONAME
declare -a REPOPATH=()
rcd-set_repopath() {
	local -A nameindex
	local -a paths
	split paths "${O[path]}" ':'

	local path
	for path in "${paths[@]}"; do
		[[ ${path} ]] || continue

		if [[ ${path} == default ]]; then
			# use q to avoid portageq's slow startup
			q -Cqo | while IFS= read -r path; do
				# gentoo: /var/db/repos/gentoo (main)
				path=${path% (*)}
				path=${path#*: }
				_rcd-set_repopath_add_if_unique
				:
			done || die "failed to read repos.conf with q -Cqo"
		else
			# allow tilde expansion for convenience
			[[ ${path} =~ ^(~[^/]*)(.*) ]] &&
				path=$(eval "echo ${BASH_REMATCH[1]}")${BASH_REMATCH[2]}
			_rcd-set_repopath_add_if_unique
		fi
	done

	(( ${#REPOPATH[@]} )) || die "no valid repo paths found, see \`${0##*/} --help\`"
}
_rcd-set_repopath_add_if_unique() {
	if [[ -d ${path} ]] && pushd "${path}" >/dev/null; then #!SC2164
		# use PWD to normalize path string
		local file=${PWD}/profiles/repo_name
		if [[ -f ${file} ]]; then
			name=$(<"${file}") || die "failed to read '${file}'"
			if [[ ! -v nameindex['${name}'] ]] || ${O[duplicates]}; then
				REPONAME[${path}]=${name}
				REPOPATH+=("${PWD}")
				nameindex[${name}]=
			fi
		else
			rcd-msg '!ra' "${PWD}: ignored path (lacks profiles/repo_name)"
		fi
		popd >/dev/null
	else
		rcd-msg '!ra' "${path}: ignored path (not a directory)"
	fi
}

rcd-set_repopath
if rcd-cd "${@}"; then
	rcd-set_atom_and_si
	if (( ${#ATOM[@]} )); then
		rcd-print_package_data

		# TODO: self-note taking system that reminds when cd to work on stuff

		# TODO: just a test command, plans are to allow to run any commands #!SC2012
		ls -1v --color=always | map array
		rcd-msg '_g' "${array[@]}"
	fi
fi

# vim: ts=4
